<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>field</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      /* Use dynamic viewport height to account for mobile address bars */
      height: 100dvh; 
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: black; /* Fallback */
    }

    body {
      position: fixed; /* Locks the body in place on iOS/Android */
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    /* Common styles */
    .cube, .ghost-cube {
      position: absolute;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      color: white;
      text-transform: lowercase;
      letter-spacing: 0.02em;
      user-select: none;
      text-decoration: none;
      will-change: transform;
      -webkit-tap-highlight-color: transparent; /* Removes blue tap box on mobile */
    }

    .cube {
      mix-blend-mode: difference;
      z-index: 5;
    }

    .ghost-cube {
      background: #333;
      opacity: 0.4;
      font-size: 20px;
      transition: opacity 0.3s;
      z-index: 1;
    }

    .ghost-cube.playing {
      opacity: 0.8;
      background: #ff0066;
      box-shadow: 0 0 20px #ff0066;
      z-index: 50;
    }

    .signature {
      position: fixed;
      bottom: 16px;
      right: 20px;
      font-size: 16px;
      letter-spacing: 0.05em;
      opacity: 0.7;
      z-index: 10;
      pointer-events: none;
      mix-blend-mode: difference;
      color: white;
    }

    #bgPlayer {
      position: absolute;
      visibility: hidden;
      width: 1px; 
      height: 1px;
    }

    .music-control {
      position: fixed;
      bottom: 16px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      z-index: 999;
      display: none;
      cursor: pointer;
      mix-blend-mode: difference;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .music-control.active {
      display: block;
    }

    /* Browser popup overlay */
    .browser-popup {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 10000;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .browser-popup.active {
      display: flex;
    }

    .popup-content {
      background: white;
      padding: 30px;
      border-radius: 12px;
      max-width: 400px;
      text-align: center;
      color: #111;
    }

    .popup-content h2 {
      margin: 0 0 15px 0;
      font-size: 20px;
      color: #ff0066;
    }

    .popup-content p {
      margin: 0 0 20px 0;
      font-size: 14px;
      line-height: 1.6;
      color: #555;
    }

    .popup-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .popup-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .popup-btn.primary {
      background: #ff0066;
      color: white;
    }

    .popup-btn.primary:hover {
      background: #cc0044;
    }

    .popup-btn.secondary {
      background: #eee;
      color: #333;
    }

    .popup-btn.secondary:hover {
      background: #ddd;
    }
  </style>
</head>

<body>

  <div class="signature">priyesh</div>
  <div class="music-control" id="musicControl" onclick="toggleMusic()">⏸ pause</div>
  <div id="bgPlayer"></div>

  <!-- Browser Popup -->
  <div class="browser-popup" id="browserPopup">
    <div class="popup-content">
      <h2>⚠️ open in browser</h2>
      <p>for the best experience (especially music), please open this page in your default browser instead of this in-app browser.</p>
      <div class="popup-buttons">
        <button class="popup-btn primary" onclick="openInBrowser()">open in browser</button>
        <button class="popup-btn secondary" onclick="closePopup()">continue anyway</button>
      </div>
    </div>
  </div>

  <script>
    // --- DETECT IN-APP BROWSER ---
    function isInAppBrowser() {
      const ua = navigator.userAgent || navigator.vendor || window.opera;
      
      // Instagram
      if (ua.indexOf('Instagram') > -1) return true;
      
      // Facebook
      if (ua.indexOf('FBAN') > -1 || ua.indexOf('FBAV') > -1) return true;
      
      // Twitter
      if (ua.indexOf('Twitter') > -1) return true;
      
      // LinkedIn
      if (ua.indexOf('LinkedInApp') > -1) return true;
      
      // Snapchat
      if (ua.indexOf('Snapchat') > -1) return true;
      
      // TikTok
      if (ua.indexOf('musical_ly') > -1 || ua.indexOf('TikTok') > -1) return true;
      
      return false;
    }

    function openInBrowser() {
      // Use the full current URL including /alt
      const url = window.location.href;
      
      // For Instagram, open in external browser directly
      window.location.href = 'googlechrome://navigate?url=' + encodeURIComponent(url);
      
      // Fallback: try intent URL for Android
      setTimeout(() => {
        window.location.href = 'intent://' + url.replace(/https?:\/\//, '') + '#Intent;end';
      }, 500);
      
      // Final fallback: copy to clipboard
      setTimeout(() => {
        copyToClipboard(url);
      }, 1000);
    }

    function copyToClipboard(text) {
      // Try modern clipboard API first
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(() => {
          // Success - silently copied
        }).catch(() => {
          fallbackCopy(text);
        });
      } else {
        fallbackCopy(text);
      }
    }

    function fallbackCopy(text) {
      const input = document.createElement('input');
      input.value = text;
      input.style.position = 'fixed';
      input.style.opacity = '0';
      document.body.appendChild(input);
      input.select();
      
      try {
        document.execCommand('copy');
      } catch (err) {
        console.log('Copy failed');
      }
      
      document.body.removeChild(input);
    }

    function closePopup() {
      document.getElementById('browserPopup').classList.remove('active');
    }

    // Show popup if in-app browser detected
    if (isInAppBrowser()) {
      document.getElementById('browserPopup').classList.add('active');
    }

    // --- YOUTUBE API ---
    var tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    var firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    var player;
    function onYouTubeIframeAPIReady() {
      player = new YT.Player('bgPlayer', {
        height: '100%',
        width: '100%',
        videoId: '',
        playerVars: { 'playsinline': 1, 'controls': 0, 'disablekb': 1, 'fs': 0, 'rel': 0 },
        events: { 'onStateChange': onPlayerStateChange }
      });
    }

    function onPlayerStateChange(event) {
      if (event.data === 0) resetMusicUI();
    }

    // --- LOGIC ---
    const bgColors = ["#ff005d", "#00ffd5", "#ffe600", "#7b00ff", "#00ff44", "#ff7a00"];
    document.body.style.background = bgColors[Math.floor(Math.random() * bgColors.length)];

    const links = [
      { url: "https://priyeshranjan.com", label: "home" },
      { url: "https://priyeshowz.substack.com", label: "blog" },
      { url: "https://www.goodreads.com/priyeshowz", label: "reads" },
      { url: "https://letterboxd.com/priyeshowz", label: "boxd" },
      { url: "https://instagram.com/priyeshowz", label: "insta" },
      { url: "https://x.com/priyeshowz", label: "x" }
    ];

    const ghostLinks = [
      { videoId: "gt_Oe2yGE4o", start: 25, label: "♪" },
      { videoId: "Y1-Qymcppps", start: 6, label: "♪" },
      { videoId: "9OUurVdRGsc", start: 56, label: "♪" },
      { videoId: "6q6GtPdVHL4", start: 28, label: "♪" },
      { videoId: "gG_dA32oH44", start: 36, label: "♪" },
      { videoId: "MxEjnYdfLXU", start: 0, label: "♪" },
      { videoId: "2L1h4-EiTzM", start: 36, label: "♪" }
    ];

    let currentPlayingCube = null;
    let isPlaying = false;

    // --- VIEWPORT HELPER ---
    // This gets the REAL visible size, excluding address bars
    function getDimensions() {
      if (window.visualViewport) {
        return {
          width: window.visualViewport.width,
          height: window.visualViewport.height
        };
      }
      return {
        width: window.innerWidth,
        height: window.innerHeight
      };
    }

    function playVideo(videoId, start, cubeElement) {
      if (!player || typeof player.loadVideoById !== 'function') return;
      const musicControl = document.getElementById('musicControl');
      if (currentPlayingCube) currentPlayingCube.classList.remove('playing');
      cubeElement.classList.add('playing');
      currentPlayingCube = cubeElement;
      player.loadVideoById({ videoId: videoId, startSeconds: start });
      isPlaying = true;
      musicControl.classList.add('active');
      musicControl.textContent = '⏸ pause';
    }

    function resetMusicUI() {
      const musicControl = document.getElementById('musicControl');
      if (currentPlayingCube) {
        currentPlayingCube.classList.remove('playing');
        currentPlayingCube = null;
      }
      isPlaying = false;
      musicControl.classList.remove('active');
    }

    function toggleMusic() {
      if (!player) return;
      if (isPlaying) {
        player.stopVideo();
        resetMusicUI();
      }
    }

    function randomRange(min, max) { return min + Math.random() * (max - min); }

    class Cube {
      constructor(link, isGhost = false, ghostLink = null) {
        this.link = link;
        this.isGhost = isGhost;
        this.ghostLink = ghostLink;
        this.size = 80;
        
        const dims = getDimensions();
        // Spawn well within bounds
        this.x = randomRange(10, dims.width - this.size - 10);
        this.y = randomRange(10, dims.height - this.size - 10);
        
        this.vx = randomRange(-2, 2);
        this.vy = randomRange(-2, 2);
        this.rotation = Math.random() * 360;
        this.rotationSpeed = randomRange(-3, 3);
        
        if (isGhost) {
          this.element = document.createElement("div");
          this.element.className = "ghost-cube";
          this.element.textContent = ghostLink.label;
          this.element.onclick = () => playVideo(ghostLink.videoId, ghostLink.start, this.element);
        } else {
          this.element = document.createElement("a");
          this.element.className = "cube";
          this.element.href = link.url;
          this.element.target = "_blank";
          this.element.rel = "noopener noreferrer";
          this.element.style.background = `hsl(${Math.random() * 360}, 100%, ${50 + Math.random() * 20}%)`;
          this.element.style.fontSize = "14px";
          this.element.textContent = link.label;
        }
        
        this.element.style.width = this.size + "px";
        this.element.style.height = this.size + "px";
        document.body.appendChild(this.element);
      }

      update(labeledCubes) {
        const dims = getDimensions();
        const maxX = dims.width - this.size;
        const maxY = dims.height - this.size;

        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;

        // BOUNDARY CHECKS - WITH CLAMPING
        // We forcibly reset position (this.x = ...) to ensure it never stays out
        if (this.x <= 0) {
          this.vx = Math.abs(this.vx); // Force positive velocity
          this.x = 0;
        } else if (this.x >= maxX) {
          this.vx = -Math.abs(this.vx); // Force negative velocity
          this.x = maxX;
        }

        if (this.y <= 0) {
          this.vy = Math.abs(this.vy);
          this.y = 0;
        } else if (this.y >= maxY) {
          this.vy = -Math.abs(this.vy);
          this.y = maxY;
        }

        // Collision Logic
        if (!this.isGhost) {
          for (let other of labeledCubes) {
            if (other === this) continue;
            
            const dx = (this.x + this.size / 2) - (other.x + other.size / 2);
            const dy = (this.y + this.size / 2) - (other.y + other.size / 2);
            const distSq = dx * dx + dy * dy;
            const minDist = this.size; 

            // Optimization: check squared distance to avoid Math.sqrt every frame
            if (distSq < minDist * minDist) {
              const distance = Math.sqrt(distSq);
              
              const tempVx = this.vx;
              const tempVy = this.vy;
              this.vx = other.vx + randomRange(-0.5, 0.5);
              this.vy = other.vy + randomRange(-0.5, 0.5);
              other.vx = tempVx + randomRange(-0.5, 0.5);
              other.vy = tempVy + randomRange(-0.5, 0.5);

              const angle = Math.atan2(dy, dx);
              const overlap = minDist - distance;
              this.x += Math.cos(angle) * overlap / 2;
              this.y += Math.sin(angle) * overlap / 2;
              other.x -= Math.cos(angle) * overlap / 2;
              other.y -= Math.sin(angle) * overlap / 2;
            }
          }
        }

        this.element.style.transform = `translate3d(${this.x}px, ${this.y}px, 0) rotate(${this.rotation}deg)`;
      }
    }

    const ghostCubes = [];
    const labeledCubes = [];
    
    // Init
    const ghostCount = 5 + Math.floor(Math.random() * 2);
    for (let i = 0; i < ghostCount; i++) ghostCubes.push(new Cube(null, true, ghostLinks[i % ghostLinks.length]));
    for (let i = 0; i < links.length; i++) labeledCubes.push(new Cube(links[i], false));

    function animate() {
      for (let cube of ghostCubes) cube.update([]);
      for (let cube of labeledCubes) cube.update(labeledCubes);
      requestAnimationFrame(animate);
    }
    animate();

    // HARD RESIZE HANDLER
    // If screen rotates or address bar moves, pull everything back inside
    window.visualViewport.addEventListener('resize', () => {
      const dims = getDimensions();
      [...ghostCubes, ...labeledCubes].forEach(cube => {
        cube.x = Math.min(cube.x, dims.width - cube.size);
        cube.y = Math.min(cube.y, dims.height - cube.size);
      });
    });
  </script>

</body>
</html>